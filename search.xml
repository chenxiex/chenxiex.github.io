<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[noip2018提高组d1t2货币系统解题报告]]></title>
    <url>%2F2019%2F07%2F31%2Fnoip2018%E6%8F%90%E9%AB%98%E7%BB%84d1t2%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解题思路这道题神似noip2017里面的小凯的疑惑，但是好想很多。 显然，在这道题中，对于一个货币系统如果有一个货币面值可以被其它面值的货币表示出来，那么这个货币面值就可以被删掉（因为完全可以由其它的代替）。但是，如果一个货币面值无法被其它面值的货币表示出来，那么它就一定不能删掉，不然会导致有一些本来可以被组出来的组不出来（最明显的例子就是它本身）。所以，我们只要找出可以被其它面值的货币表示出来的货币面值数量，从总数中减去就好了。这可以用完全背包实现。根据常识，因为面值都是非负的，所以每个面值只有可能被比它小的面值组成，所以先排序，再从小到大进行完全背包即可。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;long t; long n,a[150]; bool f[30000];int main()&#123; cin&gt;&gt;t; for (long i=0;i&lt;t;i++) &#123; memset(a,0,sizeof(a)); memset(f,false,sizeof(f)); cin&gt;&gt;n; long ans=n; for (long j=0;j&lt;n;j++) &#123; cin&gt;&gt;a[j]; &#125; f[0]=true; sort(a,a+n); for (long j=0;j&lt;n;j++) &#123; if (f[a[j]]) &#123; ans--; continue; &#125; for (long k=a[j];k&lt;=a[n-1];k++) &#123; f[k]=(f[k]||f[k-a[j]]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017提高组d2t2宝藏解题报告]]></title>
    <url>%2F2019%2F07%2F31%2Fnoip2017%E6%8F%90%E9%AB%98%E7%BB%84d2t2%E5%AE%9D%E8%97%8F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解题思路因为不知道怎么dp，所以就写了个dfs。 每次dfs枚举所有已扩展的点和要扩展的点，逐一连接尝试就行。加上最优化剪枝和搜索序的改进（每次优先扩展短的道路）还有一些小剪枝后就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;long n,m,ans=0x3f3f3f3f,to[20][20],num[20],d[20],a[20][20],tmp=0,p,s[20],tot,cnt;bool cmp(int c, int b) &#123; return a[p][c]&lt;a[p][b];&#125;void dfs(long ncnt,long node)&#123; for (long i=ncnt;i&lt;=cnt;i++) &#123; long i1=s[i]; if (tot+tmp*d[i1]&gt;=ans) return; for (long j=node;j&lt;=num[i1];j++) &#123; if (d[to[i1][j]]==0) &#123; long j1=to[i1][j]; s[++cnt]=j1; d[j1]=d[i1]+1; tmp-=a[j1][to[j1][1]]; long tot1=tot; tot+=a[i1][j1]*d[i1]; dfs(i,j+1); d[j1]=0; tmp+=a[j1][to[j1][1]]; tot=tot1; cnt--; &#125; &#125; node=1; &#125; if (cnt==n) &#123; ans=min(ans,tot); return; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(a,0x3f,sizeof(a)); for (long i=0;i&lt;m;i++) &#123; long x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if (z&gt;a[x][y]) continue; if (a[x][y]==0x3f3f3f3f) &#123; to[x][++num[x]]=y; to[y][++num[y]]=x; &#125; a[x][y]=a[y][x]=z; &#125; for(long i=1;i&lt;=n;i++) &#123; p=i; sort(to[i]+1,to[i]+num[i]+1,cmp); tmp+=a[i][to[i][1]]; &#125; for (long i=1;i&lt;=n;i++) &#123; memset(s,0,sizeof(s)); tot=0; cnt=1; s[1]=i; tmp-=a[i][to[i][1]]; d[i]=1; dfs(1,1); d[i]=0; tmp+=a[i][to[i][1]]; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2018提高组d1t1铺设道路解题报告]]></title>
    <url>%2F2019%2F07%2F30%2Fnoip2018%E6%8F%90%E9%AB%98%E7%BB%84d1t1%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解题思路用笔算模拟了几组数据，发现是贪心。即对于每个坑，如果它比前面的坑大，就把它填到和前面的坑一样平，最后在一起填掉就行。 代码1234567891011121314#include&lt;iostream&gt;using namespace std;long n,ans; long a[100005];int main()&#123; cin&gt;&gt;n; for (long i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if (a[i]&gt;a[i-1]) ans+=a[i]-a[i-1]; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017提高组d2t1奶酪解题报告]]></title>
    <url>%2F2019%2F07%2F29%2Fnoip2017%E6%8F%90%E9%AB%98%E7%BB%84d2t1%E5%A5%B6%E9%85%AA%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解题思路因为是关于路径的问题，所以想到了用最短路(spfa)来写。 因为只需考虑能不能而无需考虑路径长，所以只要设定一个数组标记每个空洞是否与底面连通，然后将这些空洞全部入队，之后逐一出队并更新与这些空洞相交或相切的空洞，再将这些空洞也入队来更新其它的空洞。如果有与顶面连通的空洞入队则代表能，如果队列空了也找不到与顶面连通的点就代表不能。另外，因为每个点无需重复入队出队，所以队列的大小设为n即可。 另外，为了节省时间以及考虑只有一个空洞的情况，还应在输入时判断是否有空洞直接连通顶面和底面，如果有就存在从底面到顶面的路径，无需跑最短路。但是还是需要将所有数据读入完了才能退出循环，不能直接break，否则会导致程序无法结束。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;struct s1&#123; long x,y,z;&#125;;long t,n,h,r; s1 hole[10001]; bool d[10001]=&#123;false&#125;; long q[10001],qh=0,qt=0;double dist(long i,long j)&#123; long x1=hole[i].x,x2=hole[j].x,y1=hole[i].y,y2=hole[j].y,z1=hole[i].z,z2=hole[j].z; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));&#125;int main()&#123; cin&gt;&gt;t; for (long i=0;i&lt;t;i++) &#123; memset(d,false,sizeof(d)); memset(hole,0,sizeof(hole)); memset(q,-1,sizeof(q)); qh=0; qt=0; cin&gt;&gt;n&gt;&gt;h&gt;&gt;r; bool f=false; for (long j=0;j&lt;n;j++) &#123; cin&gt;&gt;hole[j].x&gt;&gt;hole[j].y&gt;&gt;hole[j].z; if (hole[j].z&lt;=r) &#123; d[j]=true; q[qt++]=j; if (hole[j].z+r&gt;=h) &#123; f=true;//此处不能直接break &#125; &#125; &#125; while (qh&lt;qt&amp;&amp;!f) &#123; for (long j=0;j&lt;n;j++) &#123; if (!d[j]&amp;&amp;dist(q[qh],j)&lt;=2*r) &#123; d[j]=true; q[qt++]=j; if (hole[j].z+r&gt;=h) &#123; f=true; break; &#125; &#125; &#125; qh++; &#125; cout&lt;&lt;(f?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>noip</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017提高组d1t2时间复杂度解题报告]]></title>
    <url>%2F2019%2F07%2F28%2Fnoip2017%E6%8F%90%E9%AB%98%E7%BB%84d1t2%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解题思路很明显是一道用栈的模拟题。但是由于输入格式比较特殊，涉及到字符串处理，且情况比较多，需小心调试。 首先要解决的就是输入问题。因为有空格或回车符分隔，所以可以直接用cin读入t和l，然后用getline读入时间复杂度和代码。时间复杂度用字符串o存储，代码用字符串数组r存储。 然后要解决字符串的处理问题。可以用一个子程序提取字符串中的数据。这里用子程序getn来提取字符串中第一个数或n。如果提取到数则返回数，提取到n则返回-1234。1234567891011121314151617long getn(string a)&#123; long ans=0; bool f=false; for (long i=0;i&lt;a.size();i++) &#123; if (a[i]==&apos;n&apos;) return -1234; if (a[i]&gt;=&apos;0&apos;&amp;&amp;a[i]&lt;=&apos;9&apos;) &#123; f=true; ans=ans*10+(a[i]-&apos;0&apos;); continue; &#125; if (f) return ans; &#125; if (f) return ans;&#125; 因为本题中时间复杂度实际上就是由n的次数(w)决定的，所以用子程序geto提取输入的时间复杂度存储在变量w中。12345678910111213void geto(string o)&#123; long p=o.find(&quot;(&quot;); if (o[p+1]==&apos;1&apos;) &#123; w=0; return; &#125;else&#123; p=o.find(&quot;^&quot;); string a1=o.substr(p+1,o.size()-p); w=getn(a1); &#125;&#125; 之后就进入问题的核心了。首先明确目的有两个：计算时间复杂度和判错。判错这里有个简单的优化：如果程序行数为奇数，则循环一定无法配对，是错的，可以直接输出ERR并continue。如果是偶数，就模拟循环。先不考虑程序有错误的情况。用字符数组z来模拟栈。如果一行程序以’F’开头则压栈(将变量名i存入栈中)，并提取出起始值x和终值y。如果x!=n且y=n，就将次数qw+1，否则为常数次数，无需理会。如果以’E’开头则弹栈。 接下来再考虑有错误的情况。有以下几种： ‘F’比’E’多：只需在子程序退出前检查栈是否为空即可。 ‘E’比’F’多：只需在弹栈是检查有无错误即可。 x比y大：这种情况下，程序并不会进入循环。只需定义一个标记变量flag，在进入这个循环压栈时标记，之后的代码正常压栈弹栈但不计数，在退出这个循环时取消标记即可。 还有一个特殊情况就是有多个循环并列。此时要引入一个布尔型数组yx。yx[i]标记栈中i号元素(z[i])入栈时是否进行了次数的计数。如果有，则在该元素弹栈时要将次数减1。 最后，在每次弹栈前判断，使答案mqw等于最大的求得次数qw，之后判断mqw==w？即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long t,l,w,qw=0,mqw=0,t1=0; string r[101],o; bool f[30]=&#123;false&#125;,yx[201]=&#123;false&#125;; char z[201],flag=&apos;0&apos;;long getn(string a)&#123; long ans=0; bool f=false; for (long i=0;i&lt;a.size();i++) &#123; if (a[i]==&apos;n&apos;) return -1234; if (a[i]&gt;=&apos;0&apos;&amp;&amp;a[i]&lt;=&apos;9&apos;) &#123; f=true; ans=ans*10+(a[i]-&apos;0&apos;); continue; &#125; if (f) return ans; &#125; if (f) return ans;&#125;void geto(string o)&#123; long p=o.find(&quot;(&quot;); if (o[p+1]==&apos;1&apos;) &#123; w=0; return; &#125;else&#123; p=o.find(&quot;^&quot;); string a1=o.substr(p+1,o.size()-p); w=getn(a1); &#125;&#125;bool xh()&#123; for (long i=0;i&lt;l;i++) &#123; if (r[i][0]==&apos;F&apos;) &#123; char bl=r[i][2]; if (f[(bl-&apos;a&apos;)]) return false; z[t1++]=bl; f[(bl-&apos;a&apos;)]=true; string num=r[i].substr(4,r[i].size()-3); long beg=0,end=0; beg=getn(num); num.erase(0,num.find(&quot; &quot;)); end=getn(num); if (beg==-1234&amp;&amp;end!=-1234||beg&gt;end&amp;&amp;end!=-1234) &#123; flag=bl; &#125;else&#123; if (end==-1234&amp;&amp;beg!=-1234&amp;&amp;flag==&apos;0&apos;) &#123; yx[t1-1]=true; qw++; &#125; &#125; &#125; if (r[i][0]==&apos;E&apos;) &#123; if (t1==0) return false; mqw=max(mqw,qw); t1--; if (yx[t1]) qw--; f[(z[t1]-&apos;a&apos;)]=false; yx[t1]=false; if (z[t1]==flag) flag=&apos;0&apos;; &#125; &#125; if (t1!=0) return false; return true;&#125;int main()&#123; cin&gt;&gt;t; for (long i=0;i&lt;t;i++) &#123; cin&gt;&gt;l; mqw=0; qw=0; t1=0; flag=&apos;0&apos;; memset(z,0,sizeof(z)); memset(f,false,sizeof(f)); memset(yx,false,sizeof(yx)); getline(cin,o); geto(o); for (long j=0;j&lt;l;j++) &#123; getline(cin,r[j]); &#125; if (l%2!=0) &#123; cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; &#125; if (xh()) &#123; cout&lt;&lt;(mqw==w?&quot;Yes&quot;:&quot;No&quot;)/*&lt;&lt;&quot; &quot;&lt;&lt;mqw */&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>noip</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017提高组d1t1小凯的疑惑题解]]></title>
    <url>%2F2019%2F07%2F19%2Fnoip2017%E6%8F%90%E9%AB%98%E7%BB%84d1t1%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[解题思路很明显是到数学题。题意可转换为：1对于两个互质的正整数a,b,有正整数n≠a*c+b*d(c,d均为非负整数),求n的最大值。 因为a,b互质，可以发现{0*a%b,1*a%b,(2*a)%b,(3*a)%b…((b-1)*a)%b}刚好组成了{0,1,2…b-1},即整数整除b的所有可能余数; 设x=a*c+b*d,则x%b=(a*c+b*d)%d,即x%b=a*c%b。可以得出当x%b=a*c%b时,x可表示为a*c+b*d; 因为x=a*c+b*d,a*c、b*d都为非负整数,所以a*c&lt;=x。 当x&gt;=(b-1)a时,由1.和2.可知,此时a*c%b=x%b,所以x一定可表示为a*c+b*d。 当x&lt;(b-1)a时,a*c&lt;(b-1)a,a*c%b就取不到整数整除b的所有可能余数,x%b不一定等于a*c%b。 所以n&lt;(b-1)a。另外可以知道a*c=(b-1)a-1时，取不到的余数就是(b-1)a%b,所以当n%b=(b-1)a%b且n取最大值时即为所求。 易得若n%m=z,则[n-(ym)]%m=z(y为非负整数)。 因为(b-1)a%b=(b-1)a%b,又因为n取最大值,所以n=(b-1)a-b,即n=ab-a-b。 至此题目解决。 通过代码12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; long long a,b; //注意要用long long,否则会爆 scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); printf(&quot;%lld&quot;,a*b-a-b); return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>noip</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通题库P1366二叉树输出btout]]></title>
    <url>%2F2019%2F04%2F11%2F%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B%E4%B8%80%E6%9C%AC%E9%80%9A%E9%A2%98%E5%BA%93P1366%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%93%E5%87%BAbtout%2F</url>
    <content type="text"><![CDATA[题目链接： P1366二叉树输出题目：【题目描述】 树的凹入表示法主要用于树的屏幕或打印输出，其表示的基本思想是兄弟间等长，一个结点的长度要不小于其子结点的长度。二叉树也可以这样表示，假设叶结点的长度为1，一个非叶结点的长度等于它的左右子树的长度之和。 一棵二叉树的一个结点用一个字母表示（无重复），输出时从根结点开始： 每行输出若干个结点字符（相同字符的个数等于该结点长度）， 如果该结点有左子树就递归输出左子树； 如果该结点有右子树就递归输出右子树。 假定一棵二叉树一个结点用一个字符描述，现在给出先序和中序遍历的字符串，用树的凹入表示法输出该二叉树。 【输入】 两行，每行是由字母组成的字符串（一行的每个字符都是唯一的），分别表示二叉树的先序遍历和中序遍历的序列。 【输出】 行数等于该树的结点数，每行的字母相同。 【输入样例】12ABCDEFGCBDAFEG 【输出样例】1234567AAAABBCDEEFG 解题思路： 1.看到这道题的时候，第一个想法是建树，根据先序遍历和中序遍历，用一个结构体(struct)数组来存储树，记录每个节点和它的左右子节点、父节点。建好树后从根节点递归求得长度。我看了网络上的一些题解，也是使用了这种方法，这里就不再赘述。这里提供另一种解法。 2.观察题目，题目中输出的顺序要求是：“输出时从根结点开始：每行输出若干个结点字符（相同字符的个数等于该结点长度），如果该结点有左子树就递归输出左子树；如果该结点有右子树就递归输出右子树。”想一想，这不是就是先序遍历的递归顺序吗？正好题目中给出了先序遍历，这样就有了做法： 首先，先序遍历的第一个就是根节点，因此可以在中序遍历中找到根节点，分为左右子树进行递归求长度；递归中对于每一子树，从前到后枚举先序遍历的节点，并在子树中寻找，如果找到了那就是这颗子树的根(因为先序遍历是根在前)，再次递归。递归的边界条件是如果只有子树中只有一个节点就返回1。 示例程序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;long a[256]; string q,z;long fl(long b,long e)&#123; if (b==e)//判断边界条件 &#123; for (long i=0;i&lt;q.size();i++) if (q[i]==z[b]) &#123; a[i]=1; break; &#125; return 1; &#125; else&#123; for (long i=0;i&lt;q.size();i++) &#123; for (long j=b;j&lt;=e;j++) &#123; if (q[i]==z[j]) &#123; long lsl=0,rsl=0; if (j&gt;b) lsl=fl(b,j-1);//递归左子树 if (j&lt;e) rsl=fl(j+1,e);//递归右子树 a[i]=lsl+rsl; return a[i]; &#125; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;q&gt;&gt;z; a[0]=fl(0,z.size()-1); for (long i=0;i&lt;q.size();i++) &#123; for (long j=0;j&lt;a[i];j++) cout&lt;&lt;q[i]; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++学习错误总结板]]></title>
    <url>%2F2019%2F01%2F24%2Fc%2B%2B%E5%AD%A6%E4%B9%A0%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[本板记录学习c++遇到过的坑，以避免犯同样的错误。 数组越界出现题目：信息学奥赛一本通p1268,p1269,p1272 出现原因： c++的数组范围从0到n-1，如定义a[100]中如果访问a[100]是越界的，只到a[99]。mingw编译器在出现这种错误的时候会输出正确的答案，因此很难调试出来，且样例数据普遍较小，更增加了难度。 题目中出现了多个数据范围时应谨慎审题后确认哪个数组用哪个范围。 出现危害：导致了大量的无谓调试，一定要注意这种问题！]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划之背包（未完结）]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85(%E6%9C%AA%E5%AE%8C%E7%BB%93)%2F</url>
    <content type="text"><![CDATA[背包问题是动态规划里的经典问题，大概分为01背包、完全背包和多重背包等三种。接下来一一介绍。需要注意的是，无论是背包问题还是其它动态规划问题，打表都是非常重要的步骤。如果大家有不明白或是程序出错要调试的时候，多多列表会带来很大帮助，不要因为懒而不列。 01背包问题描述有一个容量为m(m&lt;=200)的背包和n(n&lt;=30)个物品，第i件物品的重量为w[i]，价值为v[i]，请问怎样装能使背包内物品价值最大？(w,v各自的总和均小于c++long类型) 样例输入：1234510 42 13 34 57 9 样例输出：112 解题思路动态规划的问题要满足两个原则：无后效性原则和最优化原理。这里01背包问题是满足的，具体证明可自行百度，这里就不赘述了。动态规划要知道状态、状态转移方程。这里以每个物品为状态，放或不放即为决策。如果用一个二维数组f[i][j]存储最优决策，表示前i个物品在占用小于j的重量的情况下的最大价值。 则状态转移方程： 当j&lt;w[i]时：f[i][j]=f[i-1][j];(当前占用质量不足放入新物品，则不放) 当j&gt;=w[i]时：f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]);(可以放入新物品，则选择值最大的) 进一步思考可以发现，我们最后想求的最大值只是最后一次选择后的结果，前面的结果并不需要储存。因此可以有空间优化，方程优化为：f[j]=max(f[j],f[j-w[i]]+v[i]);因此可以得到代码：123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;long m,n,w[35],v[35],f[205];int main()&#123; cin&gt;&gt;m&gt;&gt;n; for (long i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; memset(f,0,sizeof(f)); for (long i=0;i&lt;n;i++) for (long j=m;j&gt;=0;j--) &#123; if (j&gt;=w[i]) f[j]=max(f[j],f[j-w[i]]+v[i]); &#125; cout&lt;&lt;f[m]; return 0;&#125; 这里要注意，第二重循环要用逆序。为什么呢？这是因为我们要求的当前状态取决于前一个状态，即之前的物品放与不放。如果使用正序循环，则f[j-w[i]]很可能就已经是放了当前物品的结果，如果再放就会出现多次选择同一物品。这是与题意不符的。 完全背包题目描述]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告栏]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%85%AC%E5%91%8A%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[域名欢迎收藏本博客！域名：q1blog.tk]]></content>
      <categories>
        <category>帮助</category>
      </categories>
      <tags>
        <tag>博客事项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown教程]]></title>
    <url>%2F2018%2F12%2F19%2FMarkdown%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[(不定时更新)这其实是本蒟蒻的练习现在Markdown语法运用越来越普遍了，特别是这个博客要用到Markdown语法，所以就写了这个教程总结，可以自己随时查阅，也希望能帮助到其他人。 基础语法：标题：Markdown标题使用在标题前加“#”即可，“#”号数量代表标题级数，“#”号越多，标题字号越小，总共支持六级，如（为了不影响目录，这里只示例最小的两个标题）：12##### 标题1###### 标题2 效果为： 标题1标题2 分段及区块引用分段的话前后空一行就行。 区块引用的话前加“&gt;”，如： &gt;hello显示为： hello 插入链接或图片这两种东西的语法很像，分别为：12[链接文字](链接网址)![图片说明](图片网址) 注意这里的网址都要包含https的完整格式，否则容易出错。如：12[百度](https://www.baidu.com)![洛天依](https://s1.ax1x.com/2018/05/19/CcqJcn.jpg) 效果为： 百度 列表（序号）markdown列表支持两种格式：有序列表和无序列表。 无序列表使用*或+或-标识 有序列表用数字加.标识（注意标识后都要有一个空格再跟内容）如：123456- 内容1- 内容2- 内容31.内容12.内容23.内容3 实际显示效果如下： 内容1 内容2 内容3 内容1 内容2 内容3 ps：对于有序列表，序号有效的只有第一个，例如上例中第一个序号为1.，那么后面的序号就是2.，3.，以此类推。即使在代码中把2.改成4.，最终显示的也是2.。注意：如果单一列表项中有多个项目，为保证渲染正常，段落首字与标识间最好保留4个空格（这个要自己尝试，不同地方显示效果不同）如：123456- 内容1 内容2- 内容3 内容4 实际效果： 内容1 内容2 内容3 内容4 同样对于对于列表中有区块引用的也应做相应缩进处理。（因为列表这东西不同地方显示效果有细微差异，所以大家要针对自己的使用环境自行调试缩进，大概就是一个或两个制表符） 分隔线有时为了排版漂亮，会在文章中加入分隔线（像本文中各个内容之间就有分隔线分隔）。markdown中加入分隔线非常简单，以下两种都可以：12---*** 但要注意如果在GitHub中使用的话，因为GitHub中标题也是“—”，所以分隔线前要空一行来区分。 强调（加粗和斜体）文本强调也是很常用到的功能，markdown中提供加粗和斜体，用*或_包裹即可，使用一个是斜体，两个是加粗。如：12*斜体***加粗** 效果如下： 斜体 加粗（注意这里符号和文本间不要空格！否则会被认为是列表） 删除线现在删除线也越来越流行了，markdown中加删除线只需将需要加删除线的文本前后用”~~”包裹即可。如文章第一句。 高级用法插入代码通过反引号（就是键盘左上角esc键下面那个。要英文符号！这很重要）。一行三个反引号，下一行开始键入代码，最后再开一行三个反引号是比较稳妥的选择。（例子文中的代码示例就是） 插入表格这是比较复杂的一个，有时还不如直接用excel做好了截图方便……但是还是要掌握。语法如下：1231|1|1-|-|-1|1|1 效果如下：1|1|1-|-|-1|1|1(因未知原因无法正常展示，请多多包涵，如有大佬知道原因请在评论区赐教！)表格第一行为标题行，下面一行控制本列格式，每个格里至少有一条”-“，”-“前加”:”表示左对齐，前后加是居中对齐，后加是右对齐，标题默认居中对齐，内容默认左对齐，内容下不能跟控制行，否则会被认为是内容。 特殊符号特殊符号即指markdown中用于控制的符号，如果要输出这些符号本身，则在前面加反斜杠”\”即可。如：12\\\! 显示效果： \ ! 特殊符号主要有：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 使用注意事项注意事项基本上文中都有讲，这里补充一些写的时候遇到过的坑。 markdown在不同编辑器、显示环境下表现差异较大，经常出现编辑器预览和最终效果不同甚至差异很大的情况，因此建议先在要使用的显示环境下进行试验再发布。 markdown中大部分语法对空格要求很严，大部分符号前都要加空格，但有些一定不能加，具体看文中示例。通常代码没有生效就是忘了空格，显示效果错误就是加多了空格。 原创文章，转载请注明出处。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
